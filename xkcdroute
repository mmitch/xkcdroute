#!/usr/bin/perl -w
#
# simple navigation software based on an idea from xkcd.org
#
# 2008 (c) by Christian Garbs <mitch@cgarbs.de>

use strict;
use Math::Trig qw(great_circle_direction great_circle_distance deg2rad rad2deg);
use Socket;

#
# Constants
#


my $gpsd_host = 'localhost';
my $gpsd_port = 2947;
my $locationfile = '~/.xkcdroute';
my $verbose = 0;
my $sleep = 5; # seconds between updates


#
# Subroutines
#


sub show_usage()
# print usage instructions
{
    print <<'EOF';
xkcdroute [ -v | --verbose ] [ -h | --help | <location> | <coordinate> ]

Displays  the   distance  and  bearing  from   your  current  position
(determined  via gpsd)  to a  selected target.   The target  is either
given via a known location or a coordinate.

A  coordinate basically  has  the form  'N51.00  E4.05' (latitude  and
longitude) or something similar.   The algorithm should detect several
variations of this  scheme.  It also parses Googlemaps  URLs when they
contain a q= parameter with numeric values for latitude and longitude.

Known locations  are read from ~/.xkcdroute.  Every  line must consist
of a location name (used for the lookup), followed by a whitespace and
a coordinate.  Empty  lines are ignored and lines  starting with # are
treated as a comment.
EOF
;
}

sub my_print(@)
# print a string if set to verbose
{
    print join(' ', @_) . "\n" if $verbose;
}

sub abend($@)
# exit with a defined error code and a message to stderr
{
    my $rc = shift @_;
    warn join(' ', @_) . "\n";
    exit $rc;
}

sub parse_coordinates($)
# try to parse a string as coordinates
{
    my $string = shift;

    if ($string =~ /(-?\d+(?:\.\d+)?)\s+(-?\d+(?:\.\d+)?)/) {
	return [$1, $2];
    }

    if ($string =~ /(-?\d+(?:\.\d+)?)\s*:\s*(-?\d+(?:\.\d+)?)/) {
	return [$1, $2];
    }

    if ($string =~ /N(-?\s*\d+(?:\.\d+)?)\s*E\s*(-?\d+(?:\.\d+)?)/i) {
	return [$1, $2];
    }

    if ($string =~ /(-?\d+(\.\d+)?)\s*N\s*(-?\d+(\.\d+)?)\s*E/i) {
	return [$1, $2];
    }

    if ($string =~ /E(-?\s*\d+(?:\.\d+)?)\s*N\s*(-?\d+(?:\.\d+)?)/i) {
	return [$2, $1];
    }

    if ($string =~ /(-?\d+(?:\.\d+)?)\s*E\s*(-?\d+(?:\.\d+)?)\s*N/i) {
	return [$2, $1];
    }

    if ($string =~ m;^http://maps\.google.*/maps\?(?:[^&]+&)*q=(-?\d+(?:\.\d+)?),(-?\d+(?:\.\d+)?);i ) {
	return [$1, $2];
    }

    return 0;
}

sub read_locations($)
# read stored locations
{
    my $file = shift;
    my @ret;

    $file =~ s/^~/$ENV{HOME}/;

    open LOCATIONS, '<', $file or die "can't open `$file': $!\n";
    while (my $line = <LOCATIONS>) {
	chomp $line;
	next if ($line =~ /^\s+$/);
	next if ($line =~ /^\s*\#/);
	
	if ($line =~ /^(\S+?)\s(.+)$/) {
	    push @ret, {
		LOCATION => $1,
		COORDINATES => $2
		};
	} else {
	    abend 3, "unparseable line $. in location database: `$line'";
	}

    }
    close LOCATIONS or die "can't close `$file': $!\n";

    my_print scalar(@ret), 'locations read';

    return \@ret;
}

sub filter_locations($$)
# filter desired location(s)
{
    my ($haystack, $needle) = (@_);

    my @ret = grep { $_->{LOCATION} =~ /$needle/ } @{$haystack};

    return \@ret;
}

# from Math::Trig manpage:  longitude, latitude
sub NESW { deg2rad($_[0]), deg2rad(90 - $_[1]) }

sub calculate_distance($$$)
# calculate distance in km from current position to target
#
# This uses a spherical model which can result in up to 0.55% error (0.3% mean error).
# See http://www.movable-type.co.uk/scripts/latlong.html and
# http://www.movable-type.co.uk/scripts/latlong-vincenty.html
# for better algorithms.
{
    my ($target, $lat1, $long1) = (@_);

    return great_circle_distance( NESW( $long1, $lat1 ), @{$target}, 6378);
}

sub calculate_bearing($$$)
# calculate direction from current position to target
{
    my ($target, $lat1, $long1) = (@_);

    return rad2deg( great_circle_direction( NESW( $long1, $lat1 ), @{$target} ) );
}


#
# Main program
#


# parse verbosity switch
if (defined $ARGV[0]) {
    if ($ARGV[0] eq '-v' or $ARGV[0] eq '--verbose') {
	$verbose = 1;
	shift @ARGV;
    }
}

# prepare variables
my $params = join ' ', @ARGV;
my $target = undef;

# handle help
if ( $params eq '-h' or $params eq '--help' ) {
    show_usage;
    exit 0;
}

# handle direct coordinates
if ( $target = parse_coordinates( $params ) ) {
    my_print 'treating arguments as coordinates';

# handle location lookup
} else {
    my_print 'treating arguments as location';
    
    my_print 'opening location database';
    my $locations = read_locations($locationfile);

    my_print 'looking for locations';
    my $targets = filter_locations($locations, $params);
    my $target_count = scalar(@{$targets});

    if ($target_count == 0) {
	abend 1, "no suitable location found.";

    } elsif ($target_count > 1) {
	my_print 'multiple locations found:';
	print "$_->{LOCATION}\n" foreach (@{$targets});
	exit 2;
    }

    my_print 'matched location', $targets->[0]->{LOCATION};
    my_print 'using coordinates', $targets->[0]->{COORDINATES};

    $target = parse_coordinates($targets->[0]->{COORDINATES});

    die "got unparseable coordinates from location database\n" unless $target;
}

# start tracking
# TODO do_stuff($target);

# one-time-conversion for target coordinates
$target = [ NESW($target->[1], $target->[0]) ];

my_print 'connecting to gpsd';
my $iaddr = inet_aton($gpsd_host) or abend 4, "unkown host: `$gpsd_host'";
my $paddr = sockaddr_in($gpsd_port, $iaddr);
my $proto = getprotobyname('tcp');

socket(SOCK, PF_INET, SOCK_STREAM, $proto) or abend 5, "socket error: $!";
connect(SOCK, $paddr) or abend 6, "connect error: $!";

# autoflush
my $old_fh = select(SOCK);
$| = 1;
select($old_fh);

my_print 'connected';

while (1) {

    my_print 'sending o';
    print SOCK "o\015\012";
    my $line = <SOCK>;

    chomp $line;
    $line =~ s/\r$//;

    my_print "received: $line";
    if ($line eq 'GPSD,O=?') {
	print scalar localtime, " NO FIX!\n";
    } else {
	my @fields = split /\s+/, $line;
	my ($timestamp, $latitude, $longitude, $course, $bearing, $distance, $turn) = ($fields[1], $fields[3], $fields[4], $fields[7], undef, undef, undef);

	$distance = calculate_distance($target, $latitude, $longitude);
	$bearing = calculate_bearing($target, $latitude, $longitude);

	if ($course eq '?') {
	    $turn = '?';
	} else {
	    $turn = $course - $bearing;
	}
	
	print scalar localtime, " N$latitude E$longitude C$course D$distance B$bearing T$turn\n";
    }

    sleep $sleep;

}

close(SOCK) or abend 7, "socket close error: $!";

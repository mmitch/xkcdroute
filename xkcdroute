#!/usr/bin/perl -w
#
# simple navigation software based on an idea from xkcd.org
#
# 2008 (c) by Christian Garbs <mitch@cgarbs.de>

use strict;
use Socket;

#
# Constants
#


my $gpsd_host = 'localhost';
my $gpsd_port = 2947;
my $locationfile = '~/.xkcdroute';
my $verbose = 0;
my $sleep = 5; # seconds between updates


#
# Subroutines
#


sub show_usage()
# print usage instructions
{
    print <<'EOF';
xkcdroute [ -v | --verbose ] [ --help | shortcut | <latitude> <longitude> ]
EOF
;
}

sub my_print(@)
# print a string if set to verbose
{
    print join(' ', @_) . "\n" if $verbose;
}

sub abend($@)
# exit with a defined error code and a message to stderr
{
    my $rc = shift @_;
    warn join(' ', @_) . "\n";
    exit $rc;
}

sub parse_coordinates($)
# try to parse a string as coordinates
{
    my $string = shift;

    if ($string =~ /(-?\d+(\.\d+)?)\s+(-?\d+(\.\d+)?)/) {
	return [$1, $3];
    }

    if ($string =~ /(-?\d+(\.\d+)?)\s*:\s*(-?\d+(\.\d+)?)/) {
	return [$1, $3];
    }

    if ($string =~ /(-?N\s*\d+(\.\d+)?)\s*E\s*(-?\d+(\.\d+)?)/i) {
	return [$1, $3];
    }

    if ($string =~ /(-?\d+(\.\d+)?)\s*N\s*(-?\d+(\.\d+)?)\s*E/i) {
	return [$1, $3];
    }

    if ($string =~ /(-?E\s*\d+(\.\d+)?)\s*N\s*(-?\d+(\.\d+)?)/i) {
	return [$3, $1];
    }

    if ($string =~ /(-?\d+(\.\d+)?)\s*E\s*(-?\d+(\.\d+)?)\s*N/i) {
	return [$3, $1];
    }

    return 0;
}

sub read_locations($)
# read stored locations
{
    my $file = shift;
    my @ret;

    $file =~ s/^~/$ENV{HOME}/;

    open LOCATIONS, '<', $file or die "can't open `$file': $!\n";
    while (my $line = <LOCATIONS>) {
	chomp $line;
	next if ($line =~ /^\s+$/);
	next if ($line =~ /^\s*\#/);
	
	if ($line =~ /^(\S+?)\s(.+)$/) {
	    push @ret, {
		LOCATION => $1,
		COORDINATES => $2
		};
	} else {
	    abend 3, "unparseable line $. in location database: `$line'";
	}

    }
    close LOCATIONS or die "can't close `$file': $!\n";

    my_print scalar(@ret), 'locations read';

    return \@ret;
}

sub filter_locations($$)
# filter desired location(s)
{
    my ($haystack, $needle) = (@_);

    my @ret = grep { $_->{LOCATION} =~ /$needle/ } @{$haystack};

    return \@ret;
}


#
# Main program
#


# parse verbosity switch
if (defined $ARGV[0]) {
    if ($ARGV[0] eq '-v' or $ARGV[0] eq '--verbose') {
	$verbose = 1;
	shift @ARGV;
    }
}

# prepare variables
my $params = join ' ', @ARGV;
my $target = undef;

# handle help
if ( $params eq '--help' ) {
    show_usage;
    exit 0;
}

# handle direct coordinates
if ( $target = parse_coordinates( $params ) ) {
    my_print 'treating arguments as coordinates';

# handle location lookup
} else {
    my_print 'treating arguments as location';
    
    my_print 'opening location database';
    my $locations = read_locations($locationfile);

    my_print 'looking for locations';
    my $targets = filter_locations($locations, $params);
    my $target_count = scalar(@{$targets});

    if ($target_count == 0) {
	abend 1, "no suitable location found.";

    } elsif ($target_count > 1) {
	my_print 'multiple locations found:';
	print "$_->{LOCATION}\n" foreach (@{$targets});
	exit 2;
    }

    my_print 'matched location', $targets->[0]->{LOCATION};
    my_print 'using coordinates', $targets->[0]->{COORDINATES};

    $target = parse_coordinates($targets->[0]->{COORDINATES});

    die "got unparseable coordinates from location database\n" unless $target;
}

# start tracking
# TODO do_stuff($target);

my_print 'connecting to gpsd';
my $iaddr = inet_aton($gpsd_host) or abend 4, "unkown host: `$gpsd_host'";
my $paddr = sockaddr_in($gpsd_port, $iaddr);
my $proto = getprotobyname('tcp');

socket(SOCK, PF_INET, SOCK_STREAM, $proto) or abend 5, "socket error: $!";
connect(SOCK, $paddr) or abend 6, "connect error: $!";

# autoflush
my $old_fh = select(SOCK);
$| = 1;
select($old_fh);

my_print 'connected';

while (1) {

    my_print 'sending o';
    print SOCK "o\015\012";
    my $line = <SOCK>;

    chomp $line;
    $line =~ s/\r$//;

    my_print "received: $line";
    if ($line eq 'GPSD,O=?') {
	print scalar localtime, " NO FIX!\n";
    } else {
	my @fields = split /\s+/, $line;
	my ($timestamp, $latitude, $longitude, $course, $bearing, $distance, $turn) = ($fields[1], $fields[3], $fields[4], $fields[7], undef, undef, undef);

	$bearing = 0; ## insert magic;
	$distance = 1; ## insert magic;

	if ($course eq '?') {
	    $turn = '?';
	} else {
	    $turn = $course - $bearing;
	}
	
	print scalar localtime, " N$latitude E$longitude C$course D$distance B$bearing T$turn\n";
    }

    sleep $sleep;

}

close(SOCK) or abend 7, "socket close error: $!";
